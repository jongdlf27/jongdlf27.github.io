---
layout: post
title: "알고리즘 제 2장: 알고리즘 분석"
description: "algorithm complexity"
categories: [algorithm]
tags: [c]
redirect_from:
  - /2020/09/01/
---
* table of contents
{:toc .toc}
# 알고리즘 분석 기초
이번에는 알고리즘 분석에 대해 이야기해볼 예정이다.  
알고리즘을 만들고 나서 실행할 때, 이 알고리즘이 얼마나 많은 자원을 소모하는지가 중요해진다. 여기서 자원이란 시간, 메모리 등을 의미한다.  
알고리즘을 분석할 때 시간 자원이 가장 큰 문제가 되는데, 이 시간 소요를 표현하기 위해 _알고리즘의 수행시간_ 을 일정한 방법으로 나타내고 있다.  
알고리즘의 수행 시간은 **입력 크기에 대하여 시간을 특정한 비율**로 표시한 것이다.  
이전 글에서 예시로 들었던 배달 매장을 다시 한번 살펴보자.  
- - -

**OneBell** "오늘은 n개의 음식을 시켜먹을꺼야!"  
그렇다면 **OneBell**은 오늘 얼마를 지불해야 할까?  
이 문제의 답은 너무나 쉽게 알 수 있다. 내가 주문할려는 음식들의 가격을 모두 더하면 된다.  

> 입력: n개의 음식의 가격  
> 출력: 모든 음식 가격의 합  

모든 음식 가격을 더하는 알고리즘은 간단하다.  
~~~ c
totalSum(price[], n)
{
  sum = 0;
  for i <- 1 to n
    sum <- sum + price[i];
  return sum;
}
~~~
입력이 n인 위의 알고리즘의 **소요 시간은 n**이다. 왜나하면 1부터 n까지 총 n번의 덧셈을 연산하면 되기 때문이다.  이처럼 우리는 특정 입력 n에 대해 알고리즘이 걸리는 시간을 n*n, 2n, logn 등으로 표시할 수 있다.  
- - -
# 알고리즘의 점근적 표기
현실에서는 입력의 크기가 주문하려는 음식의 개수, 오늘 총 방문자 수와 같이 작을 수 있다.  하지만 알고리즘의 효율성 분석을 위해서 입력의 크기를 무한하게 크게 만든다. 왜냐하면 입력에 크기가 작을때는 알고리즘의 시간 자원 사용이 애초에 문제가 되지 않기 때문이다.  
결국 알고리즘이 요구하는 시간에 대해 **점근적 분석**[^1]을 하게 된다.  점근적 분석법은 유일하거나 가장 효과적인 분석방법이 아니지만, 간단하고 환경에 대해 독립적이기 때문에 제일 광법위하게 사용되고 있다.  
점근적 표기 방법에는 총 5가지가 존재한다.  

**-1-  Ο 표기법 (Big-O Notation)**     

Ο 표기법은 어떤 알고리즘의 소요시간이 최대(max) 얼마나 걸린다는 것을 뜻한다.   
>  O(g(n)) = {f(n) | 충분히 큰 모든 n에 대하여 f(n) ≤ cg(n)인 양의 상수 c가 존재한다}  

예를 들어 5n은 O(n^2)이라고 할 수 있다. 왜냐하면 5n은 아무리 커도 n^2보다 작을 수 밖에 없기 때문이다.  
마찬가지로 5n^2 역시 O(n^2)이라고 할 수 있다. n^2에 어떠한 상수를 곱하면 5n^2보다 커지기 때문이다.  
정리하면, **O표기법은 알고리즘 실행 시간의 상한을 나타내는 표기법**이다.

**-2- Ω 표기법 (Big-Omega Notatioin)**

Ω 표기법은 어떤 알고리즘의 소요시간이 최소(min) 얼마나 걸린다는 것을 뜻한다.  
>  O(g(n)) = {f(n) | 충분히 큰 모든 n에 대하여 cg(n) ≤ f(n)인 양의 상수 c가 존재한다}  

예를 들어 5n^2은 Ω(n)이라고 할 수 있다. 왜냐하면 n에 어떤 상수를 곱해도 5n^2보다 클 수 없기 때문이다.  
마찬가지로 5n^2은 Ω(n^2)이라고 할 수 있다. n^2에 1~4를 곱하면 5n^2보다 작기 때문이다.  

정리하면, **Ω표기법은 알고리즘 실행 시간의 하한을 나타내는 표기법**이다.  

**-3- Θ 표기법 (Big-Theta Notation)**

Θ 표기법은 어떤 알고리즘의 소요시간이 대략 어느정도 걸린다는 것을 뜻한다.  
~~~ dev
Θ(g(n)) = O(g(n)) ∩ Ω(g(n))
~~~
Θ 표기법은 O 표기법과 Ω 표기법의 합집합이다. 그래서 알고리즘의 최대 소요시간과 최소 소요시간의 사이에 있는 어떠한 부분을 표시한다고 생각하면 된다. 이를 정확하게 표현하면,
> O(g(n)) = {f(n) | 충분히 큰 모든 n에 대하여 c1g(n) ≤ f(n) ≤ c2g(n)인 양의 상수 c1, c2가 존재한다}

계속 예시로 든 5n^2은 O(n^2)도 가능하고, Ω(n^2)도 가능하다. 그러면 정의에 따라서 5n^2은 Θ(n^2)으로 표시할 수 있다.  

정리하면, **Θ 표기법은 알고리즘 실행 시간의 근접한 한계값을 나타내는 표기법**이다.  

**-4- o 표기법 (Little-o Notation)**  

o 표기법은 어떤 알고리즘의 소요시간의 증가율이 최대(max) 얼마나 걸린다는 것을 뜻한다.
<img itemprop="image" src="/assets/image/al02_1.svg" style="width:150px; height:250px;" alt="Overview" />  
이런식으로 정의한다. 풀어서 이야기하면,
> O(g(n)) = {f(n) | n이 충분히 크면 모든 c>0에 대하여 f(n) ＜ cg(n)이다}

예를 들어 5n은 o(n^2)이다. 왜냐하면 n의 기울기보다 n^2의 기울기가 더 크기 때문이다.  
하지만 0.5n^2은 o(n^2)에 속하지 않는다. o안의 함수의 기울기가 더 크지 않기 떄문이다.  

정리하면, **o 표기법은 알고리즘 함수의 기울기 상의 상한을 나타내는 표기법**이다.  

**-5- ω 표기법 (Little-Omega Notation)**

ω 표기법은 어떤 알고리즘의 소요시간의 증가율이 최소(min) 얼마나 걸린다는 것을 뜻한다.  
<img itemprop="image" src="/assets/image/al02_2.svg" style="width:150px; height:250px;" alt="Overview" />  
이런식으로 정의한다. 풀어서 이야기하면,
> O(g(n)) = {f(n) | n이 충분히 크면 모든 c>0에 대하여 g(n) ＜ cf(n)이다}

예를 들어 5n^2은 ω(n)이다. 왜냐하면 n^2 함수의 기울기 증가율이 더 크기 때문이다.  하지만 5n^2은 ω(n^2)에 속하지 않는다. ω안 함수의 기울기가 더 크지 않기 때문이다.  

정리하면, **ω 표기법은 알고리즘 함수의 기울기 상의 하한을 나타내는 표기법**이다.  

# 알고리즘의 분석

앞서 설명한 점근적 분석 표기법은 상한, 하한, 중간값, 기울기 상한, 기울기 하한 값을 나타내는 표기법이다.  다 쓰임이 다르기 때문에 모두를 이해하고 있는 것이 중요하다.  
그냥 상황에 따라 가장 알맞는 표기법을 사용하면 된다.  

알고리즘의 소요시간을 분석할때 보통 _3가지 방법_ 으로 분석을 한다.
* 최선의 경우 수행시간
* 최악의 경우 수행시간
* 평균 수행 시간  

각각의 분석 방법 모두 이름 그대로, 최선, 최악, 평균 수행시간을 나타낸다.  

또한, 알고리즘의 수행시간을 점근적 표기법으로 나타내면 **시간 복잡도(Time Complexity)**을 구한다고 한다.  
앞으로의 글에서는 **최선, 최악, 그리고 평균 수행 시간**을 모두 구해볼 예정이다.  
실제 알고리즘이 쓰일 때는 최선의 경우와 평균 수행 시간은 별 의미가 없고, 최악의 경우 시간 복잡도가 의미를 가진다고 한다.
왜냐하면 알고리즘의 평균적인 경우도 최악의 경우가 되는 경우가 종종 있고, 최악의 경우의 상한을 알면 수행 시간에 대한 다른 추측이 필요 없기 때문이다.  

[^1]:입력의 개수가 무한할때 수행시간이 증가하는 성장률로 시간복잡도를 표현하는 기법 [점근표기법](https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95)  
