---
layout: post
title: "알고리즘 제 2장: 알고리즘 설계와 분석?"
description: "algorithm complexity"
categories: [algorithm]
tags: [c]
redirect_from:
  - /2020/09/01/
---
* table of contents
{:toc .toc}
# 알고리즘 분석 기초
이번에는 알고리즘 분석에 대해 이야기해볼 예정이다.  
알고리즘을 만들고 나서 실행할 때, 이 알고리즘이 얼마나 많은 자원을 소모하는지가 중요해진다. 여기서 자원이란 시간, 메모리 등을 의미한다.  
알고리즘을 분석할 때 시간 자원이 가장 큰 문제가 되는데, 이 시간 소요를 표현하기 위해 _알고리즘의 수행시간_ 을 일정한 방법으로 나타내고 있다.  
알고리즘의 수행 시간은 **입력 크기에 대하여 시간을 특정한 비율**로 표시한 것이다.  
이전 글에서 예시로 들었던 배달 매장을 다시 한번 살펴보자.  
- - -

**OneBell** "오늘은 n개의 음식을 시켜먹을꺼야!"  
그렇다면 **OneBell**은 오늘 얼마를 지불해야 할까?  
이 문제의 답은 너무나 쉽게 알 수 있다. 내가 주문할려는 음식들의 가격을 모두 더하면 된다.  

> 입력: n개의 음식의 가격  
> 출력: 모든 음식 가격의 합  

모든 음식 가격을 더하는 알고리즘은 간단하다.  
~~~ c
totalSum(price[], n)
{
  sum = 0;
  for i <- 1 to n
    sum <- sum + price[i];
  return sum;
}
~~~
입력이 n인 위의 알고리즘의 **소요 시간은 n**이다. 왜나하면 1부터 n까지 총 n번의 덧셈을 연산하면 되기 때문이다.  이처럼 우리는 특정 입력 n에 대해 알고리즘이 걸리는 시간을 n*n, 2n, logn 등으로 표시할 수 있다.  
- - -
# 알고리즘의 점근적 표기
현실에서는 입력의 크기가 주문하려는 음식의 개수, 오늘 총 방문자 수와 같이 작을 수 있다.  하지만 알고리즘의 효율성 분석을 위해서 입력의 크기를 무한하게 크게 만든다. 왜냐하면 입력에 크기가 작을때는 알고리즘의 시간 자원 사용이 애초에 문제가 되지 않기 때문이다.  
결국 알고리즘이 요구하는 시간에 대해 **점근적 분석**[^1]을 하게 된다.  점근적 분석법은 유일하거나 가장 효과적인 분석방법이 아니지만, 간단하고 환경에 대해 독립적이기 때문에 제일 광법위하게 사용되고 있다.  
점근적 표기 방법에는 총 5가지가 존재한다.  






[^1]:입력의 개수가 무한할때 수행시간이 증가하는 성장률로 시간복잡도를 표현하는 기법 [점근표기법](https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95)  
